<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        // JS面向对象的封装特性通过构造函数来体现，但是存在浪费内存的问题
        function Singer(uname, age) {
            this.uname = uname
            this.age = age
            this.sing = function () {
                console.log("我会唱歌")
            }
        }
        // 我们希望所有对象使用同一个函数，这样比较节省内存
        // 利用原型对象（prototype）实现方法共享
        // 构造函数通过原型分配的函数是所有对象所共享的
        // JS规定，每一个构造函数都有一个prototype属性，指向另一个对象，这个对象就是原型对象
        // 这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存
        // 公共属性都写到构造函数中，公共方法写到原型对象上
        // 构造函数和原型对象中的this都指向实例化对象

        // 通过原型对象数组拓展案例
        const arr = [1, 2, 3]
        Array.prototype.max = function () {
            // 原型对象中的this指向实例对象
            return Math.max(...this)
        }
        console.log(arr.max())

        // 原型对象中的constructor属性，指向该原型对象匹配的构造函数
        // true
        console.log(Singer.prototype.constructor === Singer)
        Singer.prototype = {
            // 重新写prototype的话会覆盖原原型对象，所以要重新创造construor属性表明谁是他爹
            constructor: Singer,
            sing: function () {
                console.log("我会唱歌")
            },
            dance: function () {
                console.log("我会跳舞")
            }
        }
        // 对象原型：对象都会有一个属性__proto__指向构造函数的prototype原型对象，之所以实例对象可以使用构造函数prototype原型对象中的属性和方法，就是因为实例对象有__proto__原型的存在
        const ldh = new Singer("ldh", 55)
        // true
        console.log(ldh.__proto__ === Singer.prototype)
        // true
        console.log(ldh.__proto__.constructor === Singer)

        // 原型继承
        function Person() {

        }
        function Woman() {

        }
        function Man() {

        }
        Woman.prototype = new Person()
        Man.prototype = new Person()
        Man.prototype.constructor = Man
        Woman.prototype.constructor = Woman
        Woman.prototype.baby = function () {
            console.log("babe")
        }
        const woman1 = new Woman()
        woman1.baby()

        // 原型链
        // 基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联关系是一种链状结构，称为原型链
        // 前提：只要是对象，就会有__proto__指向一个原型对象，所以prototype.__proto指向某一个原型对象
        // console.log(woman1.__proto__ === Woman.prototype)
        // console.log(Woman.prototype.__proto__ === Person.prototype)
        // console.log(Person.prototype.__proto__ === Object.prototype)
        // console.log(Object.prototype.__proto__ === null)
        // 查找规则：
        // 1.当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性
        // 2.如果没有就查找它的原型（也就是__proto__指向的prototype原型对象）
        // 3。如果还没有就查找原型对象的原型
        // __proto__对象原型的意义就在于为对象成员查找机制提供一个线路
        // 可以使用instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上




    </script>
</body>

</html>